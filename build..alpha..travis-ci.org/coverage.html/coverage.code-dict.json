{"/home/travis/build/npmtest/node-npmtest-vash/test.js":"/* istanbul instrument in package npmtest_vash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vash/lib.npmtest_vash.js":"/* istanbul instrument in package npmtest_vash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_vash = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_vash = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-vash/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-vash && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_vash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_vash\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_vash.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_vash.rollup.js'] =\n            local.assetsDict['/assets.npmtest_vash.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_vash.__dirname + '/lib.npmtest_vash.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/index.js":"var debug = require('debug')\nvar lg = debug('vash:main');\n\nvar Lexer = require('./lib/lexer');\nvar Parser = require('./lib/parser');\nvar codegen = require('./lib/codegen');\nvar runtime = require('./runtime');\nvar helperbatch = require('./lib/helperbatch');\nvar copyrtl = require('./lib/util/copyrtl');\n\n// Attach all runtime exports to enable backwards compatible behavior,\n// like `vash.install` to still be accessible in a full build.\nrequire('./lib/helpers');\ncopyrtl(exports, runtime);\n\nexports.config = {\n\n  // Parser Options\n  favorText: false,\n  // TODO: are these even needed with proper codegen?\n  saveAT: false,\n  saveTextTag: false,\n\n  // Compiler Options\n  useWith: false,\n  htmlEscape: true,\n  helpersName: 'html',\n  modelName: 'model',\n  debug: true,\n  source: null,\n  simple: false,\n\n  // Runtime options\n  asHelper: false,\n  args: null // Internal, for compiled helpers\n}\n\nexports.version = require('./package.json').version;\n\nexports.compileStream = function() {\n  // This could eventually handle waiting until a `null`\n  // is pushed into the lexer, etc.\n  throw new Error('NotImplemented');\n}\n\nexports.compile = function(markup, options) {\n\n  if(markup === '' || typeof markup !== 'string') {\n    throw new Error('Empty or non-string cannot be compiled');\n  }\n\n  var opts = copyrtl({}, exports.config, options || {});\n\n  var l = new Lexer();\n\n  l.write(markup);\n  var tokens = l.read();\n\n  var p = new Parser(opts);\n  p.write(tokens);\n  var more = true;\n  while(more !== null) more = p.read();\n\n  p.checkStack();\n\n  // Stash the original input (new lines normalized by the lexer).\n  opts.source = l.originalInput;\n\n  p.lg(p.dumpAST());\n\n  var compiled = codegen(p.stack[0], opts);\n  lg(compiled);\n  var tpl = runtime.link(compiled, opts);\n\n  return tpl;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// VASH.COMPILEHELPER\n//\n// Allow multiple helpers to be compiled as templates, for helpers that\n// do a lot of markup output.\n//\n// Takes a template such as:\n//\n//    vash.helpers.p = function(text){\n//      <p>@text</p>\n//    }\n//\n// And compiles it. The template is then added to `vash.helpers`.\n//\n// Returns the compiled templates as named properties of an object.\n//\n// This is string manipulation at its... something. It grabs the arguments\n// and function name using a regex, not actual parsing. Definitely error-\n// prone, but good enough. This is meant to facilitate helpers with complex\n// markup, but if something more advanced needs to happen, a plain helper\n// can be defined and markup added using the manual Buffer API.\nexports['compileHelper'] = helperbatch.bind(null, 'helper', exports.compile);\n\n///////////////////////////////////////////////////////////////////////////\n// VASH.COMPILEBATCH\n//\n// Allow multiple templates to be contained within the same string.\n// Templates are separated via a sourceURL-esque string:\n//\n// //@batch = tplname/or/path\n//\n// The separator is forgiving in terms of whitespace:\n//\n// // @      batch=tplname/or/path\n//\n// Is just as valid.\n//\n// Returns the compiled templates as named properties of an object.\nexports['compileBatch'] = exports['batch'] = helperbatch.bind(null, 'batch', exports.compile);","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/lexer.js":"var debug = require('debug');\nvar tokens = require('./tokens');\n\n// This pattern and basic lexer code were originally from the\n// Jade lexer, but have been modified:\n// https://github.com/visionmedia/jade/blob/master/lib/lexer.js\n\nfunction VLexer(){\n  this.lg = debug('vash:lexer');\n  this.input = '';\n  this.originalInput = '';\n  this.lineno = 1;\n  this.charno = 0;\n}\n\nmodule.exports = VLexer;\n\nVLexer.prototype = {\n\n  write: function(input) {\n    var normalized = input.replace(/\\r\\n|\\r/g, '\\n');\n\n    // Kill BOM if this is the first chunk.\n    if (this.originalInput.length == 0) {\n      normalized = normalized.replace(/^\\uFEFF/, '');\n    }\n\n    this.input += normalized;\n    this.originalInput += normalized;\n    return true;\n  },\n\n  read: function() {\n    var out = []\n      , result;\n    while(this.input.length) {\n      result = this.advance();\n      if (result) {\n        out.push(result);\n        this.lg('Read %s at line %d, column %d with content %s',\n          result.type, result.line, result.chr, result.val.replace(/(\\n)/, '\\\\n'));\n      }\n    }\n    return out;\n  },\n\n  scan: function(regexp, type){\n    var captures, token;\n    if (captures = regexp.exec(this.input)) {\n      this.input = this.input.substr((captures[1].length));\n\n      token = {\n        type: type\n        ,line: this.lineno\n        ,chr: this.charno\n        ,val: captures[1] || ''\n        ,toString: function(){\n          return '[' + this.type\n            + ' (' + this.line + ',' + this.chr + '): '\n            + this.val.replace(/(\\n)/, '\\\\n') + ']';\n        }\n      };\n\n      this.charno += captures[0].length;\n      return token;\n    }\n  }\n\n  ,advance: function() {\n\n    var i, name, test, result;\n\n    for(i = 0; i < tokens.tests.length; i += 2){\n      test = tokens.tests[i+1];\n      test.displayName = tokens.tests[i];\n\n      if(typeof test === 'function'){\n        // assume complex callback\n        result = test.call(this);\n      }\n\n      if(typeof test.exec === 'function'){\n        // assume regex\n        result = this.scan(test, tokens.tests[i]);\n      }\n\n      if( result ){\n        return result;\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/tokens.js":"// The order of these is important, as it is the order in which\n// they are run against the input string.\n// They are separated out here to allow for better minification\n// with the least amount of effort from me. :)\n\n// Any function instead of regex is called with the lexer as the\n// context.\n\n// NOTE: this is an array, not an object literal! The () around\n// the regexps are for the sake of the syntax highlighter in my\n// editor... sublimetext2\n\nvar TESTS = [\n\n  // A real email address is considerably more complex, and unfortunately\n  // this complexity makes it impossible to differentiate between an address\n  // and an AT expression.\n  //\n  // Instead, this regex assumes the only valid characters for the user portion\n  // of the address are alphanumeric, period, and %. This means that a complex email like\n  // who-something@example.com will be interpreted as an email, but incompletely. `who-`\n  // will be content, while `something@example.com` will be the email address.\n  //\n  // However, this is \"Good Enough\"© :).\n    'EMAIL', (/^([a-zA-Z0-9.%]+@[a-zA-Z0-9.\\-]+\\.(?:[a-z]{2}|co\\.uk|com|edu|net|org))\\b/)\n\n  , 'AT_STAR_OPEN', (/^(@\\*)/)\n  , 'AT_STAR_CLOSE', (/^(\\*@)/)\n\n\n  , 'AT_COLON', (/^(@\\:)/)\n  , 'AT', (/^(@)/)\n\n\n  , 'PAREN_OPEN', (/^(\\()/)\n  , 'PAREN_CLOSE', (/^(\\))/)\n\n\n  , 'HARD_PAREN_OPEN', (/^(\\[)/)\n  , 'HARD_PAREN_CLOSE', (/^(\\])/)\n\n\n  , 'BRACE_OPEN', (/^(\\{)/)\n  , 'BRACE_CLOSE', (/^(\\})/)\n\n\n  , 'HTML_TAG_VOID_CLOSE', (/^(\\/>)/)\n  , 'HTML_TAG_CLOSE', (/^(<\\/)/)\n  , 'HTML_COMMENT_OPEN', (/^(<!--+)/)\n  , 'HTML_COMMENT_CLOSE', (/^(--+>)/)\n  , 'LT_SIGN', (/^(<)/)\n  , 'GT_SIGN', (/^(>)/)\n\n  , 'ASSIGNMENT_OPERATOR', (/^(\\|=|\\^=|&=|>>>=|>>=|<<=|-=|\\+=|%=|\\/=|\\*=)\\b/) // Also =\n  , 'EQUALITY_OPERATOR', (/^(===|==|!==|!=)\\b/)\n  , 'BITWISE_SHIFT_OPERATOR', (/^(<<|>>>|>>)/)\n  , 'UNARY_OPERATOR', (/^(delete\\b|typeof\\b|void|\\+\\+|--|\\+|-|~|!)/)\n  , 'RELATIONAL_OPERATOR', (/^(<=|>=|instanceof|in)\\b/) // Also <, >\n  , 'BINARY_LOGICAL_OPERATOR', (/^(&&|\\|\\|)\\b/)\n  , 'BINARY_BITWISE_OPERATOR', (/^(&|\\^|\\|)\\b/)\n  , 'NEW_OPERATOR', (/^(new)\\b/)\n  , 'COMMA_OPERATOR', (/^(,)/)\n\n  , 'EQUAL_SIGN', (/^(=)/)\n  , 'COLON', (/^(:)/)\n  , 'PERIOD', (/^(\\.)/)\n  , 'NEWLINE', function(){\n    var token = this.scan(/^(\\n)/, exports.NEWLINE);\n    if(token){\n      this.lineno++;\n      this.charno = 0;\n    }\n    return token;\n  }\n  , 'WHITESPACE', (/^([^\\S\\n]+)/) // http://stackoverflow.com/a/3469155\n  , 'FUNCTION', (/^(function)(?![\\d\\w])/)\n  , 'BLOCK_KEYWORD', (/^(catch|do|else if|else|finally|for|function|goto|if|switch|try|while|with)(?![\\d\\w])/)\n  , 'KEYWORD', (/^(break|case|continue|instanceof|return|var)(?![\\d\\w])/)\n  , 'IDENTIFIER', (/^([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)/)\n\n  , 'DOUBLE_FORWARD_SLASH', (/^(\\/\\/)/)\n\n  , 'FORWARD_SLASH', (/^(\\/)/)\n\n  , 'BACKSLASH', (/^(\\\\)/)\n  , 'EXCLAMATION_POINT', (/^(!)/)\n  , 'DOUBLE_QUOTE', (/^(\\\")/)\n  , 'SINGLE_QUOTE', (/^(\\')/)\n\n  , 'NUMERAL', (/^([0-9])/)\n  , 'CONTENT', (/^([^\\s])/)\n\n];\n\nexports.tests = TESTS;\n\n// Export all the tokens as constants.\nfor(var i = 0; i < TESTS.length; i += 2) {\n  exports[TESTS[i]] = TESTS[i];\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/parser.js":"\nvar debug = require('debug');\n\nvar tks = require('./tokens');\nvar nodestuff = require('./nodestuff');\nvar error = require('./error');\nvar namer = require('./util/fn-namer');\n\nvar ProgramNode = namer(require('./nodes/program'));\nvar TextNode = namer(require('./nodes/text'));\nvar MarkupNode = namer(require('./nodes/markup'));\nvar MarkupCommentNode = namer(require('./nodes/markupcomment'));\nvar MarkupContentNode = namer(require('./nodes/markupcontent'));\nvar MarkupAttributeNode = namer(require('./nodes/markupattribute'));\nvar ExpressionNode = namer(require('./nodes/expression'));\nvar ExplicitExpressionNode = namer(require('./nodes/explicitexpression'));\nvar IndexExpressionNode = namer(require('./nodes/indexexpression'));\nvar LocationNode = namer(require('./nodes/location'));\nvar BlockNode = namer(require('./nodes/block'));\nvar CommentNode = namer(require('./nodes/comment'));\nvar RegexNode = namer(require('./nodes/regex'));\n\nfunction Parser(opts) {\n  this.lg = debug('vash:parser');\n  this.tokens = [];\n  this.deferredTokens = [];\n  this.node = null;\n  this.stack = [];\n  this.inputText = '';\n  this.opts = opts || {};\n  this.previousNonWhitespace = null\n}\n\nmodule.exports = Parser;\n\nParser.prototype.decorateError = function(err, line, column) {\n  err.message = ''\n    + err.message\n    + ' at template line ' + line\n    + ', column ' + column + '\\n\\n'\n    + 'Context: \\n'\n    + error.context(this.inputText, line, column, '\\n')\n    + '\\n';\n\n  return err;\n}\n\nParser.prototype.write = function(tokens) {\n  if (!Array.isArray(tokens)) tokens = [tokens];\n  this.inputText += tokens.map(function(tok) { return tok.val; }).join('');\n  this.tokens.unshift.apply(this.tokens, tokens.reverse());\n}\n\nParser.prototype.read = function() {\n  if (!this.tokens.length && !this.deferredTokens.length) return null;\n\n  if (!this.node) {\n    this.openNode(new ProgramNode());\n    this.openNode(new MarkupNode(), this.node.body);\n    this.node._finishedOpen = true;\n    this.node.name = 'text';\n    updateLoc(this.node, { line: 0, chr: 0 })\n    this.openNode(new MarkupContentNode(), this.node.values);\n    updateLoc(this.node, { line: 0, chr: 0 })\n  }\n\n  var curr = this.deferredTokens.pop() || this.tokens.pop();\n\n  // To find this value we must search through both deferred and\n  // non-deferred tokens, since there could be more than just 3\n  // deferred tokens.\n  // nextNonWhitespaceOrNewline\n  var nnwon = null;\n\n  for (var i = this.deferredTokens.length-1; i >= 0; i--) {\n    if (\n      nnwon\n      && nnwon.type !== tks.WHITESPACE\n      && nnwon.type !== tks.NEWLINE\n    ) break;\n    nnwon = this.deferredTokens[i];\n  }\n\n  for (var i = this.tokens.length-1; i >= 0; i--) {\n    if (\n      nnwon\n      && nnwon.type !== tks.WHITESPACE\n      && nnwon.type !== tks.NEWLINE\n    ) break;\n    nnwon = this.tokens[i];\n  }\n\n  var next = this.deferredTokens.pop() || this.tokens.pop();\n  var ahead = this.deferredTokens.pop() || this.tokens.pop();\n\n  var dispatch = 'continue' + this.node.constructor.name;\n\n  this.lg('Read: %s', dispatch);\n  this.lg('  curr %s', curr);\n  this.lg('  next %s', next);\n  this.lg('  ahead %s', ahead);\n  this.lg('  nnwon %s', nnwon);\n\n  if (curr._considerEscaped) {\n    this.lg('  Previous token was marked as escaping');\n  }\n\n  var consumed = this[dispatch](this.node, curr, next, ahead, nnwon);\n\n  if (ahead) {\n    // ahead may be undefined when about to run out of tokens.\n    this.deferredTokens.push(ahead);\n  }\n\n  if (next) {\n    // Next may be undefined when about to run out of tokens.\n    this.deferredTokens.push(next);\n  }\n\n  if (!consumed) {\n    this.lg('Deferring curr %s', curr);\n    this.deferredTokens.push(curr);\n  } else {\n\n    if (curr.type !== tks.WHITESPACE) {\n      this.lg('set previousNonWhitespace %s', curr);\n      this.previousNonWhitespace = curr;\n    }\n\n    // Poor man's ASI.\n    if (curr.type === tks.NEWLINE) {\n      this.lg('set previousNonWhitespace %s', null);\n      this.previousNonWhitespace = null;\n    }\n\n    if (!curr._considerEscaped && curr.type === tks.BACKSLASH) {\n      next._considerEscaped = true;\n    }\n  }\n}\n\nParser.prototype.checkStack = function() {\n  // Throw if something is unclosed that should be.\n  var i = this.stack.length-1;\n  var node;\n  var msg;\n  // A full AST is always:\n  // Program, Markup, MarkupContent, ...\n  while(i >= 2) {\n    node = this.stack[i];\n    if (node.endOk && !node.endOk()) {\n      // Attempt to make the error readable\n      delete node.values;\n      msg = 'Found unclosed ' + node.type;\n      var err = new Error(msg);\n      err.name = 'UnclosedNodeError';\n      throw this.decorateError(\n        err,\n        node.startloc.line,\n        node.startloc.column);\n    }\n    i--;\n  }\n}\n\n// This is purely a utility for debugging, to more easily inspect\n// what happened while parsing something.\nParser.prototype.flag = function(node, name, value) {\n  var printVal = (value && typeof value === 'object')\n    ? value.type\n    : value;\n  this.lg('Flag %s on node %s was %s now %s',\n    name, node.type, node[name], printVal);\n  node[name] = value;\n}\n\nParser.prototype.dumpAST = function() {\n  if (!this.stack.length) {\n    var msg = 'No AST to dump.';\n    throw new Error(msg);\n  }\n\n  return JSON.stringify(this.stack[0], null, '  ');\n}\n\nParser.prototype.openNode = function(node, opt_insertArr) {\n  this.stack.push(node);\n  this.lg('Opened node %s from %s',\n    node.type, (this.node ? this.node.type : null));\n  this.node = node;\n\n  if (opt_insertArr) {\n    opt_insertArr.push(node);\n  }\n\n  return node;\n}\n\nParser.prototype.closeNode = function(node) {\n  var toClose = this.stack[this.stack.length-1];\n  if (node !== toClose) {\n    var msg = 'InvalidCloseAction: '\n      + 'Expected ' + node.type + ' in stack, instead found '\n      + toClose.type;\n    throw new Error(msg);\n  }\n\n  this.stack.pop();\n  var last = this.stack[this.stack.length-1];\n\n  this.lg('Closing node %s (%s), returning to node %s',\n    node.type, node.name, last.type)\n\n  this.node = last;\n}\n\nParser.prototype.continueCommentNode = function(node, curr, next) {\n  var valueNode = ensureTextNode(node.values);\n\n  if (curr.type === tks.AT_STAR_OPEN && !node._waitingForClose) {\n    this.flag(node, '_waitingForClose', tks.AT_STAR_CLOSE)\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (curr.type === node._waitingForClose) {\n    this.flag(node, '_waitingForClose', null)\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return true;\n  }\n\n  if (curr.type === tks.DOUBLE_FORWARD_SLASH && !node._waitingForClose){\n    this.flag(node, '_waitingForClose', tks.NEWLINE);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueMarkupNode = function(node, curr, next) {\n  var valueNode = node.values[node.values.length-1];\n\n  if (curr.type === tks.LT_SIGN && !node._finishedOpen) {\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (\n    !node._finishedOpen\n    && curr.type !== tks.GT_SIGN\n    && curr.type !== tks.LT_SIGN\n    && curr.type !== tks.WHITESPACE\n    && curr.type !== tks.NEWLINE\n    && curr.type !== tks.HTML_TAG_VOID_CLOSE\n  ) {\n\n    // Assume tag name\n\n    if (\n      curr.type === tks.AT\n      && !curr._considerEscaped\n      && next\n      && next.type === tks.AT\n    ) {\n      next._considerEscaped = true;\n      return true;\n    }\n\n    if (curr.type === tks.AT && !curr._considerEscaped) {\n      this.flag(node, 'expression', this.openNode(new ExpressionNode()));\n      updateLoc(node.expression, curr);\n      return true;\n    }\n\n    node.name = node.name\n      ? node.name + curr.val\n      : curr.val;\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (curr.type === tks.GT_SIGN && !node._waitingForFinishedClose) {\n    this.flag(node, '_finishedOpen', true);\n\n    if (MarkupNode.isVoid(node.name)) {\n      this.flag(node, 'isVoid', true);\n      this.closeNode(node);\n      updateLoc(node, curr);\n    } else {\n      valueNode = this.openNode(new MarkupContentNode(), node.values);\n      updateLoc(valueNode, curr);\n    }\n\n    return true;\n  }\n\n  if (curr.type === tks.GT_SIGN && node._waitingForFinishedClose) {\n    this.flag(node, '_waitingForFinishedClose', false);\n    this.closeNode(node);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  // </VOID\n  if (\n    curr.type === tks.HTML_TAG_CLOSE\n    && next\n    && next.type === tks.IDENTIFIER\n    && MarkupNode.isVoid(next.val)\n  ) {\n    throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);\n  }\n\n  // </\n  if (curr.type === tks.HTML_TAG_CLOSE) {\n    this.flag(node, '_waitingForFinishedClose', true);\n    this.flag(node, 'isClosed', true);\n    return true;\n  }\n\n  // -->\n  if (curr.type === tks.HTML_COMMENT_CLOSE) {\n    this.flag(node, '_waitingForFinishedClose', false);\n    this.closeNode(node);\n    return false;\n  }\n\n  if (curr.type === tks.HTML_TAG_VOID_CLOSE) {\n    this.closeNode(node);\n    this.flag(node, 'isVoid', true);\n    this.flag(node, 'voidClosed', true);\n    this.flag(node, 'isClosed', true);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (node._waitingForFinishedClose) {\n    this.lg('Ignoring %s while waiting for closing GT_SIGN',\n      curr);\n    return true;\n  }\n\n  if (\n    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)\n    && !node._finishedOpen\n    && next.type !== tks.HTML_TAG_VOID_CLOSE\n    && next.type !== tks.GT_SIGN\n    && next.type !== tks.NEWLINE\n    && next.type !== tks.WHITESPACE\n  ) {\n    // enter attribute\n    valueNode = this.openNode(new MarkupAttributeNode(), node.attributes);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  // Whitespace between attributes should be ignored.\n  if (\n    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)\n    && !node._finishedOpen\n  ) {\n    updateLoc(node, curr);\n    return true;\n  }\n\n  // Can't really have non-markupcontent within markup, so implicitly open\n  // a node. #68.\n  if (node._finishedOpen) {\n    valueNode = this.openNode(new MarkupContentNode(), this.node.values);\n    updateLoc(valueNode, curr);\n    return false; // defer\n  }\n\n  // Default\n\n  //valueNode = ensureTextNode(node.values);\n  //appendTextValue(valueNode, curr);\n  //return true;\n}\n\nParser.prototype.continueMarkupAttributeNode = function(node, curr, next) {\n\n  var valueNode;\n\n  if (\n    curr.type === tks.AT\n    && !curr._considerEscaped\n    && next\n    && next.type === tks.AT\n  ) {\n    next._considerEscaped = true;\n    return true;\n  }\n\n  if (curr.type === tks.AT && !curr._considerEscaped) {\n    // To expression\n\n    valueNode = this.openNode(new ExpressionNode(), !node._finishedLeft\n      ? node.left\n      : node.right);\n\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  // End of left, value only\n  if (\n    !node._expectRight\n    && (curr.type === tks.WHITESPACE\n      || curr.type === tks.GT_SIGN\n      || curr.type === tks.HTML_TAG_VOID_CLOSE)\n  ) {\n    this.flag(node, '_finishedLeft', true);\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return false; // defer\n  }\n\n  // End of left.\n  if (curr.type === tks.EQUAL_SIGN && !node._finishedLeft) {\n    this.flag(node, '_finishedLeft', true);\n    this.flag(node, '_expectRight', true);\n    return true;\n  }\n\n  // Beginning of quoted value.\n  if (\n    node._expectRight\n    && !node.rightIsQuoted\n    && (curr.type === tks.DOUBLE_QUOTE\n    || curr.type === tks.SINGLE_QUOTE)\n  ) {\n    this.flag(node, 'rightIsQuoted', curr.val);\n    return true;\n  }\n\n  // End of quoted value.\n  if (node.rightIsQuoted === curr.val) {\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return true;\n  }\n\n  // Default\n\n  if (!node._finishedLeft) {\n    valueNode = ensureTextNode(node.left);\n  } else {\n    valueNode = ensureTextNode(node.right);\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueMarkupContentNode = function(node, curr, next, ahead) {\n  var valueNode = ensureTextNode(node.values);\n\n  if (curr.type === tks.HTML_COMMENT_OPEN) {\n    valueNode = this.openNode(new MarkupCommentNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (curr.type === tks.HTML_COMMENT_CLOSE) {\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return false;\n  }\n\n  if (curr.type === tks.AT_COLON && !curr._considerEscaped) {\n    this.flag(node, '_waitingForNewline', true);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  if (curr.type === tks.NEWLINE && node._waitingForNewline === true) {\n    this.flag(node, '_waitingForNewline', false);\n    appendTextValue(valueNode, curr);\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return true;\n  }\n\n  if (\n    curr.type === tks.AT\n    && !curr._considerEscaped\n    && next.type === tks.BRACE_OPEN\n  ) {\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  if (\n    curr.type === tks.AT\n    && !curr._considerEscaped\n    && (next.type === tks.BLOCK_KEYWORD\n      || next.type === tks.FUNCTION)\n  ) {\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  // Mark @@: or @@ as escaped.\n  if (\n    curr.type === tks.AT\n    && !curr._considerEscaped\n    && next\n    && (\n      next.type === tks.AT_COLON\n      || next.type === tks.AT\n      || next.type === tks.AT_STAR_OPEN\n    )\n  ) {\n    next._considerEscaped = true;\n    return true;\n  }\n\n  // @something\n  if (curr.type === tks.AT && !curr._considerEscaped) {\n    valueNode = this.openNode(new ExpressionNode(), node.values);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  if (curr.type === tks.AT_STAR_OPEN && !curr._considerEscaped) {\n    this.openNode(new CommentNode(), node.values);\n    return false;\n  }\n\n  var parent = this.stack[this.stack.length-2];\n\n  // If this MarkupContent is the direct child of a block, it has no way to\n  // know when to close. So in this case it should assume a } means it's\n  // done. Or if it finds a closing html tag, of course.\n  if (\n    curr.type === tks.HTML_TAG_CLOSE\n    || (curr.type === tks.BRACE_CLOSE\n      && parent && parent.type === 'VashBlock')\n  ) {\n    this.closeNode(node);\n    updateLoc(node, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.LT_SIGN\n    && next\n    && (\n      // If next is an IDENTIFIER, then try to ensure that it's likely an HTML\n      // tag, which really can only be something like:\n      // <identifier>\n      // <identifer morestuff (whitespace)\n      // <identifier\\n\n      // <identifier@\n      // <identifier-\n      // <identifier:identifier // XML namespaces etc etc\n      (next.type === tks.IDENTIFIER\n        && ahead\n        && (\n          ahead.type === tks.GT_SIGN\n          || ahead.type === tks.WHITESPACE\n          || ahead.type === tks.NEWLINE\n          || ahead.type === tks.AT\n          || ahead.type === tks.UNARY_OPERATOR\n          || ahead.type === tks.COLON\n        )\n      )\n      || next.type === tks.AT)\n  ) {\n    // TODO: possibly check for same tag name, and if HTML5 incompatible,\n    // such as p within p, then close current.\n    valueNode = this.openNode(new MarkupNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  // Ignore whitespace if the direct parent is a block. This is for backwards\n  // compatibility with { @what() }, where the ' ' between ) and } should not\n  // be included as content. This rule should not be followed if the\n  // whitespace is contained within an @: escape or within favorText mode.\n  if (\n    curr.type === tks.WHITESPACE\n    && !node._waitingForNewline\n    && !this.opts.favorText\n    && parent\n    && parent.type === 'VashBlock'\n  ) {\n    return true;\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueMarkupCommentNode = function(node, curr, next) {\n  var valueNode = node.values[node.values.length-1];\n\n  if (curr.type === tks.HTML_COMMENT_OPEN) {\n    this.flag(node, '_finishedOpen', true);\n    this.flag(node, '_waitingForClose', tks.HTML_COMMENT_CLOSE);\n    updateLoc(node, curr);\n    valueNode = this.openNode(new MarkupContentNode(), node.values);\n    return true;\n  }\n\n  if (curr.type === tks.HTML_COMMENT_CLOSE && node._finishedOpen) {\n    this.flag(node, '_waitingForClose', null);\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return true;\n  }\n\n  valueNode = ensureTextNode(node.values);\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueExpressionNode = function(node, curr, next) {\n  var valueNode = node.values[node.values.length-1];\n  var pnw = this.previousNonWhitespace;\n\n  if (\n    curr.type === tks.AT\n    && next.type === tks.HARD_PAREN_OPEN\n  ) {\n    // LEGACY: @[], which means a legacy escape to content.\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return true;\n  }\n\n  if (curr.type === tks.PAREN_OPEN) {\n    this.openNode(new ExplicitExpressionNode(), node.values);\n    return false;\n  }\n\n  if (\n    curr.type === tks.HARD_PAREN_OPEN\n    && node.values[0]\n    && node.values[0].type === 'VashExplicitExpression'\n  ) {\n    // @()[0], hard parens should be content\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return false;\n  }\n\n  if (\n    curr.type === tks.HARD_PAREN_OPEN\n    && next.type === tks.HARD_PAREN_CLOSE\n  ) {\n    // [], empty index should be content (php forms...)\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return false;\n  }\n\n  if (curr.type === tks.HARD_PAREN_OPEN) {\n    this.openNode(new IndexExpressionNode(), node.values);\n    return false;\n  }\n\n  if (\n    curr.type === tks.FORWARD_SLASH\n    && pnw\n    && pnw.type === tks.AT\n  ) {\n    this.openNode(new RegexNode(), node.values)\n    return false;\n  }\n\n  // Default\n  // Consume only specific cases, otherwise close.\n\n  if (curr.type === tks.PERIOD && next && next.type === tks.IDENTIFIER) {\n    valueNode = ensureTextNode(node.values);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (curr.type === tks.IDENTIFIER) {\n\n    if (node.values.length > 0 && valueNode && valueNode.type !== 'VashText') {\n      // Assume we just ended an explicit expression.\n      this.closeNode(node);\n      return false;\n    }\n\n    valueNode = ensureTextNode(node.values);\n    appendTextValue(valueNode, curr);\n    return true;\n  } else {\n    this.closeNode(node);\n    return false;\n  }\n}\n\nParser.prototype.continueExplicitExpressionNode = function(node, curr, next) {\n\n  var valueNode = node.values[node.values.length-1];\n\n  if (\n    node.values.length === 0\n    && (curr.type === tks.AT || curr.type === tks.PAREN_OPEN)\n  ) {\n    // This is the beginning of the explicit (mark as consumed)\n    this.flag(node, '_waitingForParenClose', true);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (curr.type === tks.PAREN_OPEN && !node._waitingForEndQuote) {\n    // New explicit expression\n    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);\n    updateLoc(valueNode, curr);\n    // And do nothing with the token (mark as consumed)\n    return true;\n  }\n\n  if (curr.type === tks.PAREN_CLOSE && !node._waitingForEndQuote) {\n    // Close current explicit expression\n    this.flag(node, '_waitingForParenClose', false);\n    updateLoc(node, curr);\n    this.closeNode(node);\n    // And do nothing with the token (mark as consumed)\n    return true;\n  }\n\n  if (curr.type === tks.FUNCTION && !node._waitingForEndQuote) {\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.LT_SIGN\n    && next.type === tks.IDENTIFIER\n    && !node._waitingForEndQuote\n  ) {\n    // Markup within expression\n    valueNode = this.openNode(new MarkupNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  var pnw = this.previousNonWhitespace;\n\n  if (\n    curr.type === tks.FORWARD_SLASH\n    && !node._waitingForEndQuote\n    && pnw\n    && pnw.type !== tks.IDENTIFIER\n    && pnw.type !== tks.NUMERAL\n    && pnw.type !== tks.PAREN_CLOSE\n  ) {\n    valueNode = this.openNode(new RegexNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  // Default\n  valueNode = ensureTextNode(node.values);\n\n  if (\n    !node._waitingForEndQuote\n    && (curr.type === tks.SINGLE_QUOTE || curr.type === tks.DOUBLE_QUOTE)\n  ) {\n    this.flag(node, '_waitingForEndQuote', curr.val);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (\n    curr.val === node._waitingForEndQuote\n    && !curr._considerEscaped\n  ) {\n    this.flag(node, '_waitingForEndQuote', null);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueRegexNode = function(node, curr, next) {\n  var valueNode = ensureTextNode(node.values);\n\n  if (\n    curr.type === tks.FORWARD_SLASH\n    && !node._waitingForForwardSlash\n    && !curr._considerEscaped\n  ) {\n    // Start of regex.\n    this.flag(node, '_waitingForForwardSlash', true);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (\n    curr.type === tks.FORWARD_SLASH\n    && node._waitingForForwardSlash\n    && !curr._considerEscaped\n  ) {\n    // \"End\" of regex.\n    this.flag(node, '_waitingForForwardSlash', null);\n    this.flag(node, '_waitingForFlags', true);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (node._waitingForFlags) {\n    this.flag(node, '_waitingForFlags', null);\n    this.closeNode(node);\n\n    if (curr.type === tks.IDENTIFIER) {\n      appendTextValue(valueNode, curr);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  if (\n    curr.type === tks.BACKSLASH\n    && !curr._considerEscaped\n  ) {\n    next._considerEscaped = true;\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nParser.prototype.continueBlockNode = function(node, curr, next, ahead, nnwon) {\n\n  var valueNode = node.values[node.values.length-1];\n\n  if (curr.type === tks.AT_STAR_OPEN) {\n    this.openNode(new CommentNode(), node.body);\n    return false;\n  }\n\n  if (curr.type === tks.DOUBLE_FORWARD_SLASH && !node._waitingForEndQuote) {\n    this.openNode(new CommentNode(), node.body);\n    return false;\n  }\n\n  if (\n    curr.type === tks.AT_COLON\n    && (!node.hasBraces || node._reachedOpenBrace)\n  ) {\n    valueNode = this.openNode(new MarkupContentNode(), node.values);\n    return false;\n  }\n\n  if (\n    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)\n    && !node._reachedOpenBrace\n    && !node.keyword\n  ) {\n    this.flag(node, 'keyword', curr.val);\n    return true;\n  }\n\n  if (\n    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)\n    && !node._reachedOpenBrace\n  ) {\n    // Assume something like if (test) expressionstatement;\n    this.flag(node, 'hasBraces', false);\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (\n    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)\n    && !node._reachedCloseBrace\n    && node.hasBraces\n    && !node._waitingForEndQuote\n  ) {\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (\n    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)\n    && node._reachedCloseBrace\n    && !node._waitingForEndQuote\n  ) {\n    valueNode = this.openNode(new BlockNode(), node.tail);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.BRACE_OPEN\n    && !node._reachedOpenBrace\n    && !node._waitingForEndQuote\n  ) {\n    this.flag(node, '_reachedOpenBrace', true);\n    this.flag(node, 'hasBraces', true);\n    if (this.opts.favorText) {\n      valueNode = this.openNode(new MarkupContentNode(), node.values);\n      updateLoc(valueNode, curr);\n    }\n    return true;\n  }\n\n  if (\n    curr.type === tks.BRACE_OPEN\n    && !node._waitingForEndQuote\n  ) {\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.BRACE_CLOSE\n    && node.hasBraces\n    && !node._reachedCloseBrace\n    && !node._waitingForEndQuote\n  ) {\n    updateLoc(node, curr);\n    this.flag(node, '_reachedCloseBrace', true);\n\n    // Try to leave whitespace where it belongs, and allow `else {` to\n    // be continued as the tail of this block.\n    if (\n      nnwon\n      && nnwon.type !== tks.BLOCK_KEYWORD\n    ) {\n      this.closeNode(node);\n    }\n\n    return true;\n  }\n\n  if (\n    curr.type === tks.BRACE_CLOSE\n    && !node.hasBraces\n  ) {\n    // Probably something like:\n    // @{ if() <span></span> }\n    this.closeNode(node);\n    updateLoc(node, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.LT_SIGN\n    && (next.type === tks.AT || next.type === tks.IDENTIFIER)\n    && !node._waitingForEndQuote\n    && node._reachedCloseBrace\n  ) {\n    this.closeNode(node);\n    updateLoc(node, curr);\n    return false;\n  }\n\n  if (\n    curr.type === tks.LT_SIGN\n    && (next.type === tks.AT || next.type === tks.IDENTIFIER)\n    && !node._waitingForEndQuote\n    && !node._reachedCloseBrace\n  ) {\n    valueNode = this.openNode(new MarkupNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  if (curr.type === tks.HTML_TAG_CLOSE) {\n    if (\n      (node.hasBraces && node._reachedCloseBrace)\n      || !node._reachedOpenBrace\n    ) {\n      updateLoc(node, curr);\n      this.closeNode(node);\n      return false;\n    }\n\n    // This is likely an invalid markup configuration, something like:\n    // @if(bla) { <img></img> }\n    // where <img> is an implicit void. Try to help the user in this\n    // specific case.\n    if (\n      next\n      && next.type === tks.IDENTIFIER\n      && MarkupNode.isVoid(next.val)\n    ){\n      throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);\n    }\n  }\n\n  if (\n    curr.type === tks.AT\n    && (next.type === tks.BLOCK_KEYWORD\n      || next.type === tks.BRACE_OPEN\n      || next.type === tks.FUNCTION)\n  ) {\n    // Backwards compatibility, allowing for @for() { @for() { @{ } } }\n    valueNode = this.openNode(new BlockNode(), node.values);\n    updateLoc(valueNode, curr);\n    // TODO: shouldn't this need a more accurate target (tail, values, head)?\n    return true;\n  }\n\n  if (\n    curr.type === tks.AT && next.type === tks.PAREN_OPEN\n  ) {\n    // Backwards compatibility, allowing for @for() { @(exp) }\n    valueNode = this.openNode(new ExpressionNode(), node.values);\n    updateLoc(valueNode, curr);\n    return true;\n  }\n\n  var attachmentNode;\n\n  if (node._reachedOpenBrace && node._reachedCloseBrace) {\n    attachmentNode = node.tail;\n  } else if (!node._reachedOpenBrace) {\n    attachmentNode = node.head;\n  } else {\n    attachmentNode = node.values;\n  }\n\n  valueNode = attachmentNode[attachmentNode.length-1];\n\n  if (\n    curr.type === tks.AT\n    && next.type === tks.IDENTIFIER\n    && !node._waitingForEndQuote\n  ) {\n\n    if (node._reachedCloseBrace) {\n      this.closeNode(node);\n      return false;\n    } else {\n      // something like @for() { @i }\n      valueNode = this.openNode(new MarkupContentNode(), attachmentNode);\n      updateLoc(valueNode, curr);\n      return false;\n    }\n  }\n\n  if (\n    curr.type !== tks.BLOCK_KEYWORD\n    && curr.type !== tks.PAREN_OPEN\n    && curr.type !== tks.WHITESPACE\n    && curr.type !== tks.NEWLINE\n    && node.hasBraces\n    && node._reachedCloseBrace\n  ) {\n    // Handle if (test) { } content\n    updateLoc(node, curr);\n    this.closeNode(node);\n    return false;\n  }\n\n  if (curr.type === tks.PAREN_OPEN) {\n    valueNode = this.openNode(new ExplicitExpressionNode(), attachmentNode);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  valueNode = ensureTextNode(attachmentNode);\n\n  if (\n    curr.val === node._waitingForEndQuote\n    && !curr._considerEscaped\n  ) {\n    this.flag(node, '_waitingForEndQuote', null);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (\n    !node._waitingForEndQuote\n    && (curr.type === tks.DOUBLE_QUOTE || curr.type === tks.SINGLE_QUOTE)\n  ) {\n    this.flag(node, '_waitingForEndQuote', curr.val);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  var pnw = this.previousNonWhitespace;\n\n  if (\n    curr.type === tks.FORWARD_SLASH\n    && !node._waitingForEndQuote\n    && pnw\n    && pnw.type !== tks.IDENTIFIER\n    && pnw.type !== tks.NUMERAL\n    && pnw.type !== tks.PAREN_CLOSE\n  ) {\n    // OH GAWD IT MIGHT BE A REGEX.\n    valueNode = this.openNode(new RegexNode(), attachmentNode);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\n// These are really only used when continuing on an expression (for now):\n// @model.what[0]()\n// And apparently work for array literals...\nParser.prototype.continueIndexExpressionNode = function(node, curr, next) {\n  var valueNode = node.values[node.values.length-1];\n\n  if (node._waitingForEndQuote) {\n    if (curr.val === node._waitingForEndQuote) {\n      this.flag(node, '_waitingForEndQuote', null);\n    }\n\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  if (\n    curr.type === tks.HARD_PAREN_OPEN\n    && !valueNode\n  ) {\n    this.flag(node, '_waitingForHardParenClose', true);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (curr.type === tks.HARD_PAREN_CLOSE) {\n    this.flag(node, '_waitingForHardParenClose', false);\n    this.closeNode(node);\n    updateLoc(node, curr);\n    return true;\n  }\n\n  if (curr.type === tks.PAREN_OPEN) {\n    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);\n    updateLoc(valueNode, curr);\n    return false;\n  }\n\n  valueNode = ensureTextNode(node.values);\n\n  if (!node._waitingForEndQuote\n    && (curr.type === tks.DOUBLE_QUOTE\n    || curr.type === tks.SINGLE_QUOTE)\n  ) {\n    this.flag(node, '_waitingForEndQuote', curr.val);\n    appendTextValue(valueNode, curr);\n    return true;\n  }\n\n  // Default.\n\n  appendTextValue(valueNode, curr);\n  return true;\n}\n\nfunction updateLoc(node, token) {\n  var loc;\n  loc = new LocationNode();\n  loc.line = token.line;\n  loc.column = token.chr;\n\n  if (node.startloc === null) {\n    node.startloc = loc;\n  }\n\n  node.endloc = loc;\n}\n\nfunction ensureTextNode(valueList) {\n  var valueNode = valueList[valueList.length-1];\n\n  if (!valueNode || valueNode.type !== 'VashText') {\n    valueNode = new TextNode();\n    valueList.push(valueNode);\n  }\n\n  return valueNode;\n}\n\nfunction appendTextValue(textNode, token) {\n  if (!('value' in textNode)) {\n    var msg = 'Expected TextNode but found ' + textNode.type\n      + ' when appending token ' + token;\n    throw new Error(msg);\n  }\n\n  textNode.value += token.val;\n  updateLoc(textNode, token);\n}\n\nfunction newUnexpectedClosingTagError(parser, tok, tagName) {\n  var err = new Error(''\n    + 'Found a closing tag for a known void HTML element: '\n    + tagName + '.');\n  err.name = 'UnexpectedClosingTagError';\n  return parser.decorateError(\n    err,\n    tok.line,\n    tok.chr);\n}\n\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodestuff.js":"function clean(node) {\n  return Object.keys(node).reduce(function(out, key) {\n    var value = node[key];\n    if (key[0] !== '_' && typeof value !== 'function') {\n      if (Array.isArray(value)) {\n        out[key] = value.map(clean);\n      } else {\n        out[key] = value;\n      }\n    }\n    return out;\n  }, {});\n}\n\nexports.clean = clean;\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/error.js":"\nexports.context = function(input, lineno, columnno, linebreak) {\n  linebreak = linebreak || '!LB!';\n\n  var lines = input.split(linebreak)\n    , contextSize = lineno === 0 && columnno === 0 ? lines.length - 1 : 3\n    , start = Math.max(0, lineno - contextSize)\n    , end = Math.min(lines.length, lineno + contextSize);\n\n  return lines\n    .slice(start, end)\n    .map(function(line, i, all){\n      var curr = i + start + 1;\n\n      return (curr === lineno ? '  > ' : '    ')\n        + (curr < 10 ? ' ' : '')\n        + curr\n        + ' | '\n        + line;\n    }).join('\\n');\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/util/fn-namer.js":"var lg = require('debug')('vash:fn-namer');\nvar reName = /^function\\s+([A-Za-z0-9_]+)\\s*\\(/;\n\nmodule.exports = function(fn) {\n  if (fn.name) {\n    lg('bailing, found .name %s', fn.name);\n    return fn;\n  }\n  var fnstr = fn.toString();\n  var match = reName.exec(fnstr);\n  if (!match) {\n    lg('bailing, could not match within %s', fnstr);\n    return fn;\n  }\n  fn.name = match[1];\n  lg('set .name as %s', fn.name);\n  return fn;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/program.js":"module.exports = function ProgramNode() {\n  this.type = 'VashProgram';\n  this.body = [];\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/text.js":"module.exports = function TextNode() {\n  this.type = 'VashText';\n  this.value = '';\n  this.startloc = null;\n  this.endloc = null;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/markup.js":"var Node = module.exports = function MarkupNode() {\n  this.type = 'VashMarkup';\n  this.name = null;\n  this.expression = null; // or ExpressionNode\n  this.attributes = [];\n  this.values = [];\n  this.isVoid = false;\n  this.voidClosed = false;\n  this.isClosed = false;\n  this.startloc = null;\n  this.endloc = null;\n\n  this._finishedOpen = false;\n  // Waiting for the finishing > of the </close>\n  this._waitingForFinishedClose = false;\n}\n\nvar voids = module.exports.voids = [\n\n  // Just a little bit of cheating.\n  '!DOCTYPE', '!doctype', 'doctype',\n\n  // From the spec\n  'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n  'link', 'meta', 'param', 'source', 'track', 'wbr'\n];\n\nNode.isVoid = function(name) {\n  return voids.indexOf(name) > -1;\n}\n\n// HTML5 allows these to be non-closed.\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#generate-implied-end-tags\nvar implieds = [\n  'dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'\n]\n\nNode.isImplied = function(name) {\n  return implieds.indexOf(name) > -1;\n}\n\nNode.prototype.endOk = function() {\n\n  if (\n    this._finishedOpen\n    && (this.isClosed || this.voidClosed)\n  ) {\n    return true;\n  }\n\n  return false;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/markupcomment.js":"var Node = module.exports = function MarkupCommentNode() {\n  this.type = 'VashMarkupComment';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._finishedOpen = false\n  this._waitingForClose = null;\n}\n\nNode.prototype.endOk = function() {\n  return this._waitingForClose || this._finishedOpen\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/markupcontent.js":"var Node = module.exports = function MarkupContentNode() {\n  this.type = 'VashMarkupContent';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._waitingForNewline = null;\n}\n\nNode.prototype.endOk = function() {\n  return this._waitingForNewline\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/markupattribute.js":"var Node = module.exports = function MarkupAttributeNode() {\n  this.type = 'VashMarkupAttribute';\n  this.left = [];\n  this.right = [];\n  this.rightIsQuoted = false;\n  this.startloc = null;\n  this.endloc = null;\n\n  this._finishedLeft = false;\n  this._expectRight = false;\n}\n\nNode.prototype.endOk = function() {\n  // TODO: this should include expecting right + found quotes or not.\n  return this._finishedLeft\n    ? true\n    : false;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/expression.js":"var Node = module.exports = function ExpressionNode() {\n  this.type = 'VashExpression';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/explicitexpression.js":"var Node = module.exports = function ExplicitExpressionNode() {\n  this.type = 'VashExplicitExpression';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._waitingForParenClose = null;\n  this._waitingForEndQuote = null;\n}\n\nNode.prototype.endOk = function() {\n  return this._waitingForEndQuote || this._waitingForParenClose\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/indexexpression.js":"var Node = module.exports = function IndexExpressionNode() {\n  this.type = 'VashIndexExpression';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._waitingForEndQuote = null;\n  this._waitingForHardParenClose = null;\n}\n\nNode.prototype.endOk = function() {\n  return (this._waitingForEndQuote || this._waitingForHardParenClose)\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/location.js":"module.exports = function LocationNode() {\n  this.line = 1;\n  this.column = 0;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/block.js":"var Node = module.exports = function BlockNode() {\n  this.type = 'VashBlock';\n  this.keyword = null;\n  this.head = [];\n  this.values = [];\n  this.tail = [];\n  this.hasBraces = null;\n  this.startloc = null;\n  this.endloc = null;\n\n  this._reachedOpenBrace = false;\n  this._reachedCloseBrace = false;\n  this._withinCommentLine = false;\n  this._waitingForEndQuote = null;\n}\n\nNode.prototype.endOk = function() {\n  var gradeSchool = this.hasBraces\n    && (!this._reachedOpenBrace || !this._reachedCloseBrace);\n\n  return (gradeSchool || this._withinCommentLine || this._waitingForEndQuote)\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/comment.js":"var Node = module.exports = function CommentNode() {\n  this.type = 'VashComment';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._waitingForClose = null;\n}\n\nNode.prototype.endOk = function() {\n  return this._waitingForClose\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/nodes/regex.js":"\n// Need to handle:\n// if (true) /abc/.test()\n// if (/abc/.test('what'))\n// @(/abc/.exec('abc'))\n// @{ var re = /abc/gi; }\n// if (a/b) {}\n// @(a/=b) // Previous is IDENTIFIER or WHITESPACE\n\nvar Node = module.exports = function RegexNode() {\n  this.type = 'VashRegex';\n  this.values = [];\n  this.startloc = null;\n  this.endloc = null;\n\n  this._waitingForForwardSlash = null;\n  this._waitingForFlags = null;\n}\n\nNode.prototype.endOk = function() {\n  return this._waitingForForwardSlash || this._waitingForFlags\n    ? false\n    : true;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/codegen.js":"\nvar debug = require('debug');\nvar lg = debug('vash:codegen');\n\nvar gens = {}\n\ngens.VashProgram = function(node, opts, generate) {\n  return node.body.map(generate).join('');\n}\n\ngens.VashExplicitExpression = function(node, opts, generate) {\n  var str = node.values.map(generate).join('');\n  str = '(' + maybeHTMLEscape(node, opts, str) + ')';\n  if (parentIsContent(node)) {\n    str = bewrap(str);\n  }\n  return str;\n}\n\ngens.VashExpression = function(node, opts, generate) {\n  var str = node.values.map(generate).join('');\n  str = bewrap(maybeHTMLEscape(node, opts, str));\n  return str;\n}\n\ngens.VashRegex = function(node, opts, generate) {\n  var str = node.values.map(generate).join('');\n  str = maybeHTMLEscape(node, opts, str);\n  if (parentIsContent(node)) {\n    str = bewrap(str);\n  }\n  return str;\n}\n\ngens.VashMarkup = function(node, opts, generate) {\n  var isText = node.name === 'text';\n  var name = node.name ? bcwrap(node.name) : '';\n  var tagNameValue = name\n    + (node.expression ? generate(node.expression) : '');\n\n  var tagOpen = ''\n    + bcwrap('<')\n    + tagNameValue\n    + bcwrap(node.attributes.length ? ' ' : '')\n    + node.attributes.map(generate).join(bcwrap(' '))\n\n  var values;\n  var tagClose;\n\n  if (node.isVoid) {\n    tagOpen += bcwrap(node.voidClosed ? ' />' : '>');\n    values = '';\n    tagClose = '';\n  } else {\n    tagOpen += bcwrap('>');\n    values = node.values.map(generate).join('');\n    tagClose = node.isClosed ? bcwrap('</') + tagNameValue + bcwrap('>') : '';\n  }\n\n  if (isText) {\n    tagOpen = tagClose = '';\n  }\n\n  return ''\n    + (parentIsExpression(node) ? '(function () {' : '')\n    + dbgstart(node, opts)\n    + tagOpen\n    + values\n    + tagClose\n    + dbgend(node, opts)\n    + (parentIsExpression(node) ? '}())' : '')\n}\n\ngens.VashMarkupAttribute = function(node, opts, generate) {\n  var quote = node.rightIsQuoted || '';\n  quote = escapeMarkupContent(quote);\n  return ''\n    + dbgstart(node, opts)\n    + node.left.map(generate).join('')\n    + (node.right.length || node.rightIsQuoted\n      ?   bcwrap('=' + quote)\n        + node.right.map(generate).join('')\n        + bcwrap(quote)\n      : '')\n    + dbgend(node, opts);\n}\n\ngens.VashMarkupContent = function(node, opts, generate) {\n  return ''\n    + dbgstart(node, opts)\n    + node.values.map(generate).join('')\n    + dbgend(node, opts);\n}\n\ngens.VashMarkupComment = function(node, opts, generate) {\n  return ''\n    + bcwrap('<!--')\n    + dbgstart(node, opts)\n    + node.values.map(generate).join('')\n    + dbgend(node, opts)\n    + bcwrap('-->');\n}\n\ngens.VashBlock = function(node, opts, generate) {\n  var hasValues = node.values.length > 0;\n  var unsafeForDbg = node.keyword === 'switch'\n    || !node.name\n    || !hasValues;\n  var openBrace = hasValues || node.hasBraces\n    ? '{' + (unsafeForDbg ? '' : dbgstart(node, opts))\n    : '';\n  var closeBrace = hasValues || node.hasBraces\n    ? (unsafeForDbg ? '' : dbgend(node, opts)) + '}'\n    : '';\n  return ''\n    + (node.keyword ? node.keyword : '')\n    + node.head.map(generate).join('')\n    + openBrace\n    + node.values.map(generate).join('')\n    + closeBrace\n    + node.tail.map(generate).join('');\n}\n\ngens.VashIndexExpression = function(node, opts, generate) {\n  var str = node.values.map(generate).join('');\n  return '[' + str + ']';\n}\n\ngens.VashText = function(node, opts, generate) {\n  if (!node.value.length) return '';\n  return parentIsContent(node)\n    ? ''\n      + dbgstart(node, opts)\n      + bcwrap(escapeMarkupContent(node.value))\n      + dbgend(node, opts)\n    : node.value;\n}\n\ngens.VashComment = function(node, opts, generate) {\n  return '';\n}\n\nvar reQuote = /(['\"])/g;\nvar reEscapedQuote = /\\\\+([\"'])/g;\nvar reLineBreak = /\\n/g;\nvar reHelpersName = /HELPERSNAME/g;\nvar reModelName = /MODELNAME/g;\nvar reOriginalMarkup = /ORIGINALMARKUP/g;\n\nfunction escapeMarkupContent(str) {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(reQuote, '\\\\$1')\n    .replace(reLineBreak, '\\\\n');\n}\n\nvar BUFFER_HEAD = '\\n__vbuffer.push(';\nvar BUFFER_TAIL = ');\\n';\n\n// buffer content wrap\nfunction bcwrap(str) {\n  return BUFFER_HEAD + '\\'' + str.replace(/\\n/, '\\\\n') + '\\'' + BUFFER_TAIL;\n}\n\n// buffer expression wrap\nfunction bewrap(str) {\n  return BUFFER_HEAD + str + BUFFER_TAIL;\n}\n\nfunction parentIsContent(node) {\n  return node.parent.type === 'VashMarkup'\n    || node.parent.type === 'VashMarkupContent'\n    || node.parent.type === 'VashMarkupComment'\n    || node.parent.type === 'VashMarkupAttribute'\n    || node.parent.type === 'VashProgram';\n}\n\nfunction parentIsExpression(node) {\n  return node.parent.type === 'VashExpression'\n    || node.parent.type === 'VashExplicitExpression'\n    || node.parent.type === 'VashIndexExpression';\n}\n\nfunction dbgstart(node, opts) {\n  return opts.debug\n    ? ''\n      + opts.helpersName + '.vl = ' + node.startloc.line + ', '\n      + opts.helpersName + '.vc = ' + node.startloc.column + '; \\n'\n    : '';\n}\n\nfunction dbgend(node, opts) {\n  return opts.debug\n    ? ''\n      + opts.helpersName + '.vl = ' + node.endloc.line + ', '\n      + opts.helpersName + '.vc = ' + node.endloc.column + '; \\n'\n    : '';\n}\n\nfunction maybeHTMLEscape(node, opts, str) {\n  if (parentIsContent(node) && opts.htmlEscape) {\n    return opts.helpersName + '.escape(' + str + ').toHtmlString()';\n  } else {\n    return str;\n  }\n}\n\nfunction replaceDevTokens(str, opts){\n  return str\n    .replace( reHelpersName, opts.helpersName )\n    .replace( reModelName, opts.modelName );\n}\n\nfunction head(opts){\n  var str = ''\n    + (opts.debug ? 'try { \\n' : '')\n    + 'var __vbuffer = HELPERSNAME.buffer; \\n'\n    + 'HELPERSNAME.options = __vopts; \\n'\n    + 'MODELNAME = MODELNAME || {}; \\n'\n    + (opts.useWith ? 'with( MODELNAME ){ \\n' : '');\n\n  str = replaceDevTokens(str, opts);\n  return str;\n}\n\nfunction helperHead(opts){\n  var str = ''\n    + (opts.debug ? 'try { \\n' : '')\n    + 'var __vbuffer = this.buffer; \\n'\n    + 'var MODELNAME = this.model; \\n'\n    + 'var HELPERSNAME = this; \\n';\n\n  str = replaceDevTokens(str, opts);\n  return str;\n}\n\nfunction tail(opts){\n  var str = ''\n    + (opts.simple\n      ? 'return HELPERSNAME.buffer.join(\"\"); \\n'\n      : ';(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, HELPERSNAME)); \\n'\n        + 'return (__vopts && __vopts.asContext) \\n'\n        + '  ? HELPERSNAME \\n'\n        + '  : HELPERSNAME.toString(); \\n' )\n    + (opts.useWith ? '} \\n' : '')\n    + (opts.debug ? '} catch( e ){ \\n'\n      + '  HELPERSNAME.reportError( e, HELPERSNAME.vl, HELPERSNAME.vc, \"ORIGINALMARKUP\", \"!LB!\", true ); \\n'\n      + '} \\n' : '');\n\n  str = replaceDevTokens(str, opts)\n    .replace(reOriginalMarkup, escapeForDebug(opts.source));\n\n  return str;\n}\n\n function helperTail(opts){\n  var str = ''\n    + (opts.debug ? '} catch( e ){ \\n'\n      + '  HELPERSNAME.reportError( e, HELPERSNAME.vl, HELPERSNAME.vc, \"ORIGINALMARKUP\", \"!LB!\", true ); \\n'\n      + '} \\n' : '');\n\n  str = replaceDevTokens(str, opts)\n    .replace(reOriginalMarkup, escapeForDebug(opts.source));\n\n  return str;\n}\n\nfunction escapeForDebug( str ){\n  return str\n    .replace(reLineBreak, '!LB!')\n    .replace(reQuote, '\\\\$1')\n    .replace(reEscapedQuote, '\\\\$1')\n}\n\n// Not necessary, but provides faster execution when not in debug mode\n// and looks nicer.\nfunction condenseContent(str) {\n  return str\n    .replace(/'\\);\\n+__vbuffer.push\\('/g, '')\n    .replace(/\\n+/g, '\\n');\n}\n\nfunction generate(node, opts) {\n\n  function gen(opts, node) {\n    lg('Entering ' + node.type);\n    var str = gens[node.type](node, opts, genChild);\n    lg('Leaving ' + node.type);\n    return str;\n\n    function genChild(child) {\n      if (!child.parent) child.parent = node;\n      lg('Generating child type %s of parent type %s', child.type, node.type)\n      return gen(opts, child);\n    }\n  }\n\n  var generated = gen(opts, node);\n\n  var body;\n  if(!opts.asHelper){\n    body = head(opts) + generated + tail(opts);\n  } else {\n    body = helperHead(opts) + generated + helperTail(opts);\n  }\n\n  return opts.debug\n    ? body\n    : condenseContent(body);\n}\n\nmodule.exports = generate;\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/runtime.js":"\nvar error = require('./lib/error');\nvar runtime = {\n  version: require('./package.json').version\n};\n\nvar helpers = runtime['helpers'];\n\nmodule.exports = runtime;\n\nfunction Helpers( model ) {\n  this.buffer = new Buffer();\n  this.model  = model;\n  this.options = null; // added at render time\n\n  this.vl = 0;\n  this.vc = 0;\n};\n\nruntime['helpers']\n  = helpers\n  = Helpers.prototype\n  = { constructor: Helpers, config: {}, tplcache: {} };\n\n// this allows a template to return the context, and coercion\n// will handle it\nhelpers.toString = helpers.toHtmlString = function(){\n  // not calling buffer.toString() results in 2x speedup\n  return this.buffer._vo.join('');//.toString();\n}\n\n///////////////////////////////////////////////////////////////////////////\n// HTML ESCAPING\n\nvar HTML_REGEX = /[&<>\"'`]/g\n  ,HTML_REPLACER = function(match) { return HTML_CHARS[match]; }\n  ,HTML_CHARS = {\n    \"&\": \"&amp;\"\n    ,\"<\": \"&lt;\"\n    ,\">\": \"&gt;\"\n    ,'\"': \"&quot;\"\n    ,\"'\": \"&#x27;\"\n    ,\"`\": \"&#x60;\"\n  };\n\nhelpers['raw'] = function( val ) {\n  var func = function() { return val; };\n\n  val = val != null ? val : \"\";\n\n  return {\n     toHtmlString: func\n    ,toString: func\n  };\n};\n\nhelpers['escape'] = function( val ) {\n  var func = function() { return val; };\n\n  val = val != null ? val : \"\";\n\n  if ( typeof val.toHtmlString !== \"function\" ) {\n\n    val = val.toString().replace( HTML_REGEX, HTML_REPLACER );\n\n    return {\n       toHtmlString: func\n      ,toString: func\n    };\n  }\n\n  return val;\n};\n\n// HTML ESCAPING\n///////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////////////\n// BUFFER MANIPULATION\n//\n// These are to be used from within helpers, to allow for manipulation of\n// output in a sane manner.\n\nvar Buffer = function() {\n  this._vo = [];\n}\n\nBuffer.prototype.mark = function( debugName ) {\n  var mark = new Mark( this, debugName );\n  mark.markedIndex = this._vo.length;\n  this._vo.push( mark.uid );\n  return mark;\n};\n\nBuffer.prototype.fromMark = function( mark ) {\n  var found = mark.findInBuffer();\n\n  if( found > -1 ){\n    // automatically destroy the mark from the buffer\n    mark.destroy();\n    // `found` will still be valid for a manual splice\n    return this._vo.splice( found, this._vo.length );\n  }\n\n  return [];\n};\n\nBuffer.prototype.spliceMark = function( mark, numToRemove, add ){\n  var found = mark.findInBuffer();\n\n  if( found > -1 ){\n    mark.destroy();\n    arguments[0] = found;\n    return this._vo.splice.apply( this._vo, arguments );\n  }\n\n  return [];\n};\n\nBuffer.prototype.empty = function() {\n  return this._vo.splice( 0, this._vo.length );\n};\n\nBuffer.prototype.push = function( buffer ) {\n  return this._vo.push( buffer );\n};\n\nBuffer.prototype.pushConcat = function( buffer ){\n  var buffers;\n  if (Array.isArray(buffer)) {\n    buffers = buffer;\n  } else if ( arguments.length > 1 ) {\n    buffers = Array.prototype.slice.call( arguments );\n  } else {\n    buffers = [buffer];\n  }\n\n  for (var i = 0; i < buffers.length; i++) {\n    this._vo.push( buffers[i] );\n  }\n\n  return this.__vo;\n}\n\nBuffer.prototype.indexOf = function( str ){\n\n  for( var i = 0; i < this._vo.length; i++ ){\n    if(\n      ( str.test && this._vo[i] && this._vo[i].search(str) > -1 )\n      || this._vo[i] == str\n    ){\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.lastIndexOf = function( str ){\n  var i = this._vo.length;\n\n  while( --i >= 0 ){\n    if(\n      ( str.test && this._vo[i] && this._vo[i].search(str) > -1 )\n      || this._vo[i] == str\n    ){\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.splice = function(){\n  return this._vo.splice.apply( this._vo, arguments );\n}\n\nBuffer.prototype.index = function( idx ){\n  return this._vo[ idx ];\n}\n\nBuffer.prototype.flush = function() {\n  return this.empty().join( \"\" );\n};\n\nBuffer.prototype.toString = Buffer.prototype.toHtmlString = function(){\n  // not using flush because then console.log( tpl() ) would artificially\n  // affect the output\n  return this._vo.join( \"\" );\n}\n\n// BUFFER MANIPULATION\n///////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////\n// MARKS\n// These can be used to manipulate the existing entries in the rendering\n// context. For an example, see the highlight helper.\n\nvar Mark = runtime['Mark'] = function( buffer, debugName ){\n  this.uid = '[VASHMARK-'\n    + ~~( Math.random() * 10000000 )\n    + (debugName ? ':' + debugName : '')\n    + ']';\n  this.markedIndex = 0;\n  this.buffer = buffer;\n  this.destroyed = false;\n}\n\nvar reMark = Mark.re = /\\[VASHMARK\\-\\d{1,8}(?::[\\s\\S]+?)?]/g\n\n// tests if a string has a mark-like uid within it\nMark.uidLike = function( str ){\n  return (str || '').search( reMark ) > -1;\n}\n\nMark.prototype.destroy = function(){\n\n  var found = this.findInBuffer();\n\n  if( found > -1 ){\n    this.buffer.splice( found, 1 );\n    this.markedIndex = -1;\n  }\n\n  this.destroyed = true;\n}\n\nMark.prototype.findInBuffer = function(){\n\n  if( this.destroyed ){\n    return -1;\n  }\n\n  if( this.markedIndex && this.buffer.index( this.markedIndex ) === this.uid ){\n    return this.markedIndex;\n  }\n\n  // The mark may be within a string due to block manipulation shenanigans.\n  var escaped = this.uid.replace(/(\\[|\\])/g, '\\\\$1');\n  var re = new RegExp(escaped);\n  return this.markedIndex = this.buffer.indexOf( re );\n}\n\n// MARKS\n///////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////\n// ERROR REPORTING\n\n// Liberally modified from https://github.com/visionmedia/jade/blob/master/jade.js\nhelpers.constructor.reportError = function(e, lineno, chr, orig, lb, atRenderTime){\n\n  lb = lb || '!LB!';\n\n  var contextStr = error.context(orig, lineno, chr, lb);\n\n  e.vashlineno = lineno;\n  e.vashcharno = chr;\n  e.message = 'Problem while '\n    + (atRenderTime ? 'rendering' : 'compiling')\n    + ' template at line '\n    + lineno + ', character ' + chr\n    + '.\\nOriginal message: ' + e.message + '.'\n    + '\\nContext: \\n\\n' + contextStr + '\\n\\n';\n\n  throw e;\n};\n\nhelpers['reportError'] = function() {\n  this.constructor.reportError.apply( this, arguments );\n};\n\n// ERROR REPORTING\n///////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////\n// VASH.LINK\n// Take a compiled string or function and \"link\" it to the current vash\n// runtime. This is necessary to allow instantiation of `Helpers` and\n// proper decompilation via `toClientString`.\n//\n// If `options.asHelper` and `options.args` are defined, the `cmpFunc` is\n// interpreted as a compiled helper, and is attached to `runtime.helpers` at\n// a property name equal to `options.asHelper`.\n\nruntime['link'] = function( cmpFunc, options ){\n\n  // TODO: allow options.filename to be used as sourceUrl?\n\n  var  originalFunc\n    ,cmpOpts;\n\n  if( !options.args ){\n    // every template has these arguments\n    options.args = [options.modelName, options.helpersName, '__vopts', 'runtime'];\n  }\n\n  if( typeof cmpFunc === 'string' ){\n    originalFunc = cmpFunc;\n\n    try {\n      // do not pollute the args array for later attachment to the compiled\n      // function for later decompilation/linking\n      cmpOpts = options.args.slice();\n      cmpOpts.push(cmpFunc);\n      cmpFunc = Function.apply(null, cmpOpts);\n    } catch(e) {\n      // TODO: add flag to reportError to know if it's at compile time or runtime\n      helpers.reportError(e, 0, 0, originalFunc, /\\n/, false);\n    }\n  }\n\n  // need this to enable decompilation / relinking\n  cmpFunc.options = {\n     simple: options.simple\n    ,modelName: options.modelName\n    ,helpersName: options.helpersName\n  }\n\n  var linked;\n\n  if( options.asHelper ){\n\n    cmpFunc.options.args = options.args;\n    cmpFunc.options.asHelper = options.asHelper;\n\n    linked = function(){\n      return cmpFunc.apply(this, slice.call(arguments));\n    }\n\n    helpers[options.asHelper] = linked;\n\n  } else {\n\n    linked = function( model, opts ){\n      if( options.simple ){\n        var ctx = {\n           buffer: []\n          ,escape: Helpers.prototype.escape\n          ,raw: Helpers.prototype.raw\n        }\n        return cmpFunc( model, ctx, opts, runtime );\n      }\n\n      opts = divineRuntimeTplOptions( model, opts );\n      return cmpFunc( model, (opts && opts.context) || new Helpers( model ), opts, runtime );\n    }\n  }\n\n  // show the template-specific code, instead of the generic linked function\n  linked['toString'] = function(){ return cmpFunc.toString(); }\n\n  // shortcut to show the actual linked function\n  linked['_toString'] = function(){ return Function.prototype.toString.call(linked) }\n\n  // This assumes a vash global, and should be deprecated.\n  // TODO: @deprecate\n  linked['toClientString'] = function(){\n    return 'vash.link( '\n      + cmpFunc.toString() + ', '\n      + JSON.stringify( cmpFunc.options ) + ' )';\n  }\n\n  return linked;\n}\n\n// given a model and options, allow for various tpl signatures and options:\n// ( model, {} )\n// ( model, function onRenderEnd(){} )\n// ( model )\n// and model.onRenderEnd\nfunction divineRuntimeTplOptions( model, opts ){\n\n  // allow for signature: model, callback\n  if( typeof opts === 'function' ) {\n    opts = { onRenderEnd: opts };\n  }\n\n  // allow for passing in onRenderEnd via model\n  if( model && model.onRenderEnd ){\n    opts = opts || {};\n\n    if( !opts.onRenderEnd ){\n      opts.onRenderEnd = model.onRenderEnd;\n    }\n\n    delete model.onRenderEnd;\n  }\n\n  // ensure options can be referenced\n  if( !opts ){\n    opts = {};\n  }\n\n  return opts;\n}\n\n// shortcut for compiled helpers\nvar slice = Array.prototype.slice;\n\n// VASH.LINK\n///////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////\n// TPL CACHE\n\nruntime['lookup'] = function( path, model ){\n  var tpl = runtime.helpers.tplcache[path];\n  if( !tpl ){ throw new Error('Could not find template: ' + path); }\n  if( model ){ return tpl(model); }\n  else return tpl;\n};\n\nruntime['install'] = function( path, tpl ){\n  var cache = runtime.helpers.tplcache;\n  if( typeof tpl === 'string' ){\n    // Super hacky: if the calling context has a `compile` function,\n    // then `this` is likely full vash. This is simply for backwards\n    // compatibility.\n    // TODO: @deprecate\n    if ( typeof this.compile === 'function') {\n      tpl = this.compile(tpl);\n    } else {\n      throw new Error('.install(path, [string]) is not available in the standalone runtime.');\n    }\n  } else if( typeof path === 'object' ){\n    tpl = path;\n    Object.keys(tpl).forEach(function(path){\n      cache[path] = tpl[path];\n    });\n    return cache;\n  }\n  return cache[path] = tpl;\n};\n\nruntime['uninstall'] = function( path ){\n  var  cache = runtime.helpers.tplcache\n    ,deleted = false;\n\n  if( typeof path === 'string' ){\n    return delete cache[path];\n  } else {\n    Object.keys(cache).forEach(function(key){\n      if( cache[key] === path ){ deleted = delete cache[key]; }\n    })\n    return deleted;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/helperbatch.js":"\nvar slice = Array.prototype.slice\n\n  , reHelperFuncHead = /vash\\.helpers\\.([^= ]+?)\\s*=\\s*function([^(]*?)\\(([^)]*?)\\)\\s*{/\n  , reHelperFuncTail = /\\}$/\n\n  , reBatchSeparator = /^\\/\\/\\s*@\\s*batch\\s*=\\s*(.*?)$/\n\n// The logic for compiling a giant batch of templates or several\n// helpers is nearly exactly the same. The only difference is the\n// actual compilation method called, and the regular expression that\n// determines how the giant string is split into named, uncompiled\n// template strings.\nmodule.exports = function compile(type, compile, str, options){\n\n  var separator = type === 'helper'\n    ? reHelperFuncHead\n    : reBatchSeparator;\n\n  var tpls = splitByNamedTpl(separator, str, function(ma, name){\n    return name.replace(/^\\s+|\\s+$/, '');\n  }, type === 'helper' ? true : false);\n\n  if(tpls){\n    Object.keys(tpls).forEach(function(path){\n      tpls[path] = type === 'helper'\n        ? compileSingleHelper(compile, tpls[path], options)\n        : compile('@{' + tpls[path] + '}', options);\n    });\n\n    tpls.toClientString = function(){\n      return Object.keys(tpls).reduce(function(prev, curr){\n        if(curr === 'toClientString'){\n          return prev;\n        }\n        return prev + tpls[curr].toClientString() + '\\n';\n      }, '')\n    }\n  }\n\n  return tpls;\n}\n\n// Given a separator regex and a function to transform the regex result\n// into a name, take a string, split it, and group the rejoined strings\n// into an object.\n// This is useful for taking a string, such as\n//\n//    // tpl1\n//    what what\n//    and more\n//\n//    // tpl2\n//    what what again\n//\n// and returning:\n//\n//    {\n//      tpl1: 'what what\\nand more\\n',\n//      tpl2: 'what what again'\n//    }\nvar splitByNamedTpl = function(reSeparator, markup, resultHandler, keepSeparator){\n\n  var  lines = markup.split(/[\\n\\r]/g)\n    ,tpls = {}\n    ,paths = []\n    ,currentPath = ''\n\n  lines.forEach(function(line, i){\n\n    var  pathResult = reSeparator.exec(line)\n      ,handlerResult = pathResult ? resultHandler.apply(pathResult, pathResult) : null\n\n    if(handlerResult){\n      currentPath = handlerResult;\n      tpls[currentPath] = [];\n    }\n\n    if((!handlerResult || keepSeparator) && line){\n      tpls[currentPath].push(line);\n    }\n  });\n\n  Object.keys(tpls).forEach(function(key){\n    tpls[key] = tpls[key].join('\\n');\n  })\n\n  return tpls;\n}\n\nvar compileSingleHelper = function(compile, str, options){\n\n  options = options || {};\n\n    // replace leading/trailing spaces, and parse the function head\n  var  def = str.replace(/^[\\s\\n\\r]+|[\\s\\n\\r]+$/, '').match(reHelperFuncHead)\n    // split the function arguments, kill all whitespace\n    ,args = def[3].split(',').map(function(arg){ return arg.replace(' ', '') })\n    ,name = def[1]\n    ,body = str\n      .replace( reHelperFuncHead, '' )\n      .replace( reHelperFuncTail, '' )\n\n  // Wrap body in @{} to simulate it actually being inside a function\n  // definition, since we manually stripped it. Without this, statements\n  // such as `this.what = \"what\";` that are at the beginning of the body\n  // will be interpreted as markup.\n  body = '@{' + body + '}';\n\n  // `args` and `asHelper` inform `vash.compile/link` that this is a helper\n  options.args = args;\n  options.asHelper = name;\n  return compile(body, options);\n}\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/util/copyrtl.js":"module.exports = function(obj) {\n  // extend works from right to left, using first arg as target\n  var next, i, p;\n\n  for(i = 1; i < arguments.length; i++){\n    next = arguments[i];\n\n    for(p in next){\n      obj[p] = next[p];\n    }\n  }\n\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/helpers/index.js":"require('./trim');\nrequire('./highlight');\nrequire('./layout');\nmodule.exports = require('../../runtime');","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/helpers/trim.js":"var helpers = require('../../runtime').helpers;\n\n// Trim whitespace from the start and end of a string\nhelpers.trim = function(val){\n  return val.replace(/^\\s*|\\s*$/g, '');\n}","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/helpers/highlight.js":"var helpers = require('../../runtime').helpers;\n\n///////////////////////////////////////////////////////////////////////////\n// EXAMPLE HELPER: syntax highlighting\n\nhelpers.config.highlighter = null;\n\nhelpers.highlight = function(lang, cb){\n\n  // context (this) is and instance of Helpers, aka a rendering context\n\n  // mark() returns an internal `Mark` object\n  // Use it to easily capture output...\n  var startMark = this.buffer.mark();\n\n  // cb() is simply a user-defined function. It could (and should) contain\n  // buffer additions, so we call it...\n  cb( this.model );\n\n  // ... and then use fromMark() to grab the output added by cb().\n  var cbOutLines = this.buffer.fromMark(startMark);\n\n  // The internal buffer should now be back to where it was before this\n  // helper started, and the output is completely contained within cbOutLines.\n\n  this.buffer.push( '<pre><code>' );\n\n  if( helpers.config.highlighter ){\n    this.buffer.push( helpers.config.highlighter(lang, cbOutLines.join('')).value );\n  } else {\n    this.buffer.push( cbOutLines );\n  }\n\n  this.buffer.push( '</code></pre>' );\n\n  // returning is allowed, but could cause surprising effects. A return\n  // value will be directly added to the output directly following the above.\n}\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/helpers/layout.js":"var helpers = require('../../runtime').helpers;\nvar copyrtl = require('../util/copyrtl');\n\n// For now, using the layout helpers requires a full build. For now.\nvar vash = require('../../index');\nmodule.exports = vash;\n\n///////////////////////////////////////////////////////////////////////////\n// LAYOUT HELPERS\n\n// semi hacky guard to prevent non-nodejs erroring\nif( typeof window === 'undefined' ){\n  var  fs = require('fs')\n    ,path = require('path')\n}\n\n// TRUE implies that all TPLS are loaded and waiting in cache\nhelpers.config.browser = false;\n\nvash.loadFile = function(filepath, options, cb){\n\n  // options are passed in via Express\n  // {\n  //   settings:\n  //   {\n  //      env: 'development',\n  //    'jsonp callback name': 'callback',\n  //    'json spaces': 2,\n  //    views: '/Users/drew/Dropbox/js/vash/test/fixtures/views',\n  //    'view engine': 'vash'\n  //   },\n  //   _locals: [Function: locals],\n  //   cache: false\n  // }\n\n  // The only required options are:\n  //\n  // settings: {\n  //     views: ''\n  // }\n\n  options = copyrtl({}, vash.config, options || {});\n\n  var browser = helpers.config.browser\n    ,tpl\n\n  if( !browser && options.settings && options.settings.views ){\n    // this will really only have an effect on windows\n    filepath = path.normalize( filepath );\n\n    if( filepath.indexOf( path.normalize( options.settings.views ) ) === -1 ){\n      // not an absolute path\n      filepath = path.join( options.settings.views, filepath );\n    }\n\n    if( !path.extname( filepath ) ){\n      filepath += '.' + ( options.settings['view engine'] || 'vash' )\n    }\n  }\n\n  // TODO: auto insert 'model' into arguments\n  try {\n    // if browser, tpl must exist in tpl cache\n    tpl = options.cache || browser\n      ? helpers.tplcache[filepath] || ( helpers.tplcache[filepath] = vash.compile(fs.readFileSync(filepath, 'utf8')) )\n      : vash.compile( fs.readFileSync(filepath, 'utf8') )\n\n    cb && cb(null, tpl);\n  } catch(e) {\n    cb && cb(e, null);\n  }\n}\n\nvash.renderFile = vash.__express = function(filepath, options, cb){\n\n  vash.loadFile(filepath, options, function(err, tpl){\n    // auto setup an `onRenderEnd` callback to seal the layout\n    var prevORE = options.onRenderEnd;\n\n    cb( err, !err && tpl(options, function(err, ctx){\n      ctx.finishLayout()\n      if( prevORE ) prevORE(err, ctx);\n    }) );\n  })\n}\n\nhelpers._ensureLayoutProps = function(){\n  this.appends = this.appends || {};\n  this.prepends = this.prepends || {};\n  this.blocks = this.blocks || {};\n\n  this.blockMarks = this.blockMarks || {};\n}\n\nhelpers.finishLayout = function(){\n  this._ensureLayoutProps();\n\n  var self = this, name, marks, blocks, prepends, appends, injectMark, m, content, block\n\n  // each time `.block` is called, a mark is added to the buffer and\n  // the `blockMarks` stack. Find the newest/\"highest\" mark on the stack\n  // for each named block, and insert the rendered content (prepends, block, appends)\n  // in place of that mark\n\n  for( name in this.blockMarks ){\n\n    marks = this.blockMarks[name];\n\n    prepends = this.prepends[name];\n    blocks = this.blocks[name];\n    appends = this.appends[name];\n\n    injectMark = marks.pop();\n\n    // mark current point in buffer in prep to grab rendered content\n    m = this.buffer.mark();\n\n    prepends && prepends.forEach(function(p){ self.buffer.pushConcat( p ); });\n\n    // a block might never have a callback defined, e.g. is optional\n    // with no default content\n    block = blocks.pop();\n    block && this.buffer.pushConcat( block );\n\n    appends && appends.forEach(function(a){ self.buffer.pushConcat( a ); });\n\n    // grab rendered content\n    content = this.buffer.fromMark( m )\n\n    // Join, but split out the VASHMARKS so further buffer operations are still\n    // sane. Join is required to prevent max argument errors when large templates\n    // are being used.\n    content = compactContent(content);\n\n    // Prep for apply, ensure the right location (mark) is used for injection.\n    content.unshift( injectMark, 0 );\n    this.buffer.spliceMark.apply( this.buffer, content );\n  }\n\n  for( name in this.blockMarks ){\n\n    // kill all other marks registered as blocks\n    this.blockMarks[name].forEach(function(m){ m.destroy(); });\n  }\n\n  // this should only be able to happen once\n  delete this.blockMarks;\n  delete this.prepends;\n  delete this.blocks;\n  delete this.appends;\n\n  // and return the whole thing\n  return this.toString();\n}\n\n// Given an array, condense all the strings to as few array elements\n// as possible, while preserving `Mark`s as individual elements.\nfunction compactContent(content) {\n  var re = vash.Mark.re;\n  var parts = [];\n  var str = '';\n\n  content.forEach(function(part) {\n    if (re.exec(part)) {\n      parts.push(str, part);\n      str = '';\n    } else {\n      // Ensure `undefined`s are not `toString`ed\n      str += (part || '');\n    }\n  });\n\n  // And don't forget the rest.\n  parts.push(str);\n\n  return parts;\n}\n\nhelpers.extend = function(path, ctn){\n  var  self = this\n    ,buffer = this.buffer\n    ,origModel = this.model\n    ,layoutCtx;\n\n  this._ensureLayoutProps();\n\n  // this is a synchronous callback\n  vash.loadFile(path, this.model, function(err, tpl){\n\n    if (err) throw err;\n\n    // any content that is outside of a block but within an \"extend\"\n    // callback is completely thrown away, as the destination for such\n    // content is undefined\n    var start = self.buffer.mark();\n\n    ctn(self.model);\n\n    // ... and just throw it away\n    var  content = self.buffer.fromMark( start )\n      // TODO: unless it's a mark id? Removing everything means a block\n      // MUST NOT be defined in an extend callback\n      //,filtered = content.filter( vash.Mark.uidLike )\n\n    //self.buffer.push( filtered );\n\n    // `isExtending` is necessary because named blocks in the layout\n    // will be interpreted after named blocks in the content. Since\n    // layout named blocks should only be used as placeholders in the\n    // event that their content is redefined, `block` must know to add\n    // the defined content at the head or tail or the block stack.\n    self.isExtending = true;\n    tpl( self.model, { context: self } );\n    self.isExtending = false;\n  });\n\n  this.model = origModel;\n}\n\nhelpers.include = function(name, model){\n\n  var  self = this\n    ,buffer = this.buffer\n    ,origModel = this.model;\n\n  // TODO: should this be in a new context? Jade looks like an include\n  // is not shared with parent context\n\n  // this is a synchronous callback\n  vash.loadFile(name, this.model, function(err, tpl){\n    if (err) throw err;\n    tpl( model || self.model, { context: self } );\n  });\n\n  this.model = origModel;\n}\n\nhelpers.block = function(name, ctn){\n  this._ensureLayoutProps();\n\n  var  self = this\n    // ensure that we have a list of marks for this name\n    ,marks = this.blockMarks[name] || ( this.blockMarks[name] = [] )\n    // ensure a list of blocks for this name\n    ,blocks = this.blocks[name] || ( this.blocks[name] = [] )\n    ,start\n    ,content;\n\n  // render out the content immediately, if defined, to attempt to grab\n  // \"dependencies\" like other includes, blocks, etc\n  if( ctn ){\n    start = this.buffer.mark();\n    ctn( this.model );\n    content = this.buffer.fromMark( start );\n\n    // add rendered content to named list of blocks\n    if( content.length && !this.isExtending ){\n      blocks.push( content );\n    }\n\n    // if extending the rendered content must be allowed to be redefined\n    if( content.length && this.isExtending ){\n      blocks.unshift( content );\n    }\n  }\n\n  // mark the current location as \"where this block will end up\"\n  marks.push( this.buffer.mark( 'block-' + name ) );\n}\n\nhelpers._handlePrependAppend = function( type, name, ctn ){\n  this._ensureLayoutProps();\n\n  var start = this.buffer.mark()\n    ,content\n    ,stack = this[type]\n    ,namedStack = stack[name] || ( stack[name] = [] )\n\n  ctn( this.model );\n  content = this.buffer.fromMark( start );\n\n  namedStack.push( content );\n}\n\nhelpers.append = function(name, ctn){\n  this._handlePrependAppend( 'appends', name, ctn );\n}\n\nhelpers.prepend = function(name, ctn){\n  this._handlePrependAppend( 'prepends', name, ctn );\n}\n","/home/travis/build/npmtest/node-npmtest-vash/node_modules/vash/lib/traverse.js":"\nvar visitorKeys = {\n  VashProgram: ['body'],\n  VashBlock: ['head', 'values', 'tail'],\n  VashExplicitExpression: ['values'],\n  VashExpression: ['values'],\n  VashIndexExpression: ['values'],\n  VashMarkup: ['attributes', 'values'],\n  VashMarkupAttribute: ['left', 'right'],\n  VashText: []\n}\n\nmodule.exports = function traverse(node, callbacks) {\n\n  (function walk(node, parent) {\n\n    if (!node.parent) {\n      node.parent = parent;\n    }\n\n    var ret = callbacks.enter(node);\n\n    var candidateKeys = visitorKeys[node.type];\n    if (candidateKeys) {\n      candidateKeys.forEach(function(key) {\n        var valueNodes = node[key];\n        if (valueNodes && valueNodes.length) {\n          valueNodes.forEach(function(child) {\n            walk(child, node);\n          })\n        }\n      })\n    }\n\n    ret = callbacks.leave(node);\n  }(node, null));\n}"}